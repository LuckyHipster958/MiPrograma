// Función para contar y dividir comandos separados por "&"
int separar_comandos(char *texto, char *comandos[], int max_comandos) {
    int num_comandos = 0;
    char *comando = strtok(texto, "&");
    while (comando != NULL && num_comandos < max_comandos) {
        comandos[num_comandos++] = comando;
        comando = strtok(NULL, "&");
    }
    return num_comandos;
}

// Función principal que controla la ejecución
void ejecutacomandos(char *texto) {
    char *comandos[12] = {NULL}; // Array para almacenar los comandos
    int num_comandos = separar_comandos(texto, comandos, 12); // Separar los comandos

    // Iterar sobre los comandos y ejecutarlos uno a uno
    for (int i = 0; i < num_comandos; i++) {
        ejecutar_comando(comandos[i]);
    }
}

// Función para ejecutar un único comando (ya existente, ajustada según sea necesario)
void ejecutar_comando(char *comando) {
    char *argayu[12] = {NULL};
    bool redirigir_salida = false;
    char *archivo_salida = NULL;

    // Tokenizar y manejar redirección ">"
    char *token = strtok(comando, " ");
    int i = 0;
    while (token != NULL) {
        if (strcmp(token, ">") == 0) {
            redirigir_salida = true;
            token = strtok(NULL, " ");
            if (token == NULL) {
                fprintf(stderr, "%s", error_message);
                return;
            }
            archivo_salida = token;
            break;
        }
        argayu[i++] = token;
        token = strtok(NULL, " ");
    }
    argayu[i] = NULL; // Finalizar lista de argumentos

    // Crear proceso hijo para ejecutar el comando
    pid_t pid = fork();
    if (pid == 0) { // Proceso hijo
        if (redirigir_salida) {
            int fd = open(archivo_salida, O_WRONLY | O_CREAT | O_TRUNC, 0644);
            if (fd < 0) {
                fprintf(stderr, "%s", error_message);
                exit(1);
            }
            dup2(fd, STDOUT_FILENO);
            close(fd);
        }
        execvp(argayu[0], argayu);
        fprintf(stderr, "%s", error_message);
        exit(1);
    } else if (pid > 0) { // Proceso padre
        waitpid(pid, NULL, 0);
    } else {
        fprintf(stderr, "%s", error_message);
    }
}
